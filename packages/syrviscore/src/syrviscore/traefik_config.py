"""
Traefik configuration generation for SyrvisCore.

Generates static and dynamic configuration files for Traefik reverse proxy.
Also handles Layer 2 service dynamic configurations.
"""

import os
from pathlib import Path
from typing import Any, Dict, List, Optional, TYPE_CHECKING

import yaml

if TYPE_CHECKING:
    from .service_schema import ServiceDefinition


# =============================================================================
# Synology Services Configuration
# =============================================================================
# Define Synology NAS services that can be proxied through Traefik.
# Each service has a subdomain, target port, and protocol.
#
# To add a new service:
#   1. Add an entry to SYNOLOGY_SERVICES
#   2. Set the corresponding env var to enable it (e.g., SYNOLOGY_DSM_ENABLED=true)
#   3. Run 'syrvis setup' to regenerate configs

SYNOLOGY_SERVICES = {
    # Service key: (subdomain, port, protocol, description)
    # Note: DS File removed - use SMB directly to NAS IP instead
    "photos": {
        "subdomain": "photos",
        "port": 5001,
        "protocol": "https",
        "description": "Photos (Synology Photos / Photo Station)",
        "env_enabled": "SYNOLOGY_PHOTOS_ENABLED",
    },
    "dsm": {
        "subdomain": "dsm",
        "port": 5001,
        "protocol": "https",
        "description": "DSM Web Interface",
        "env_enabled": "SYNOLOGY_DSM_ENABLED",
    },
    "drive": {
        "subdomain": "drive",
        "port": 6690,
        "protocol": "https",
        "description": "Synology Drive",
        "env_enabled": "SYNOLOGY_DRIVE_ENABLED",
    },
    "audio": {
        "subdomain": "audio",
        "port": 5001,
        "protocol": "https",
        "description": "Audio Station",
        "env_enabled": "SYNOLOGY_AUDIO_ENABLED",
    },
    "video": {
        "subdomain": "video",
        "port": 5001,
        "protocol": "https",
        "description": "Video Station",
        "env_enabled": "SYNOLOGY_VIDEO_ENABLED",
    },
}


def get_enabled_synology_services() -> Dict[str, dict]:
    """Get list of enabled Synology services from environment variables."""
    enabled = {}
    for key, config in SYNOLOGY_SERVICES.items():
        env_var = config["env_enabled"]
        if os.getenv(env_var, "").lower() in ("true", "1", "yes"):
            enabled[key] = config
    return enabled


def generate_traefik_static_config() -> str:
    """
    Generate Traefik static configuration (traefik.yml).

    Static configuration defines:
    - API/Dashboard settings
    - Entry points (ports 80, 443)
    - Providers (Docker, file-based)
    - Logging configuration
    - Let's Encrypt certificate resolver

    Returns:
        YAML content as string
    """
    acme_email = os.getenv("ACME_EMAIL", "admin@example.com")

    config = f"""# Traefik Static Configuration
# Generated by SyrvisCore

api:
  dashboard: true
  insecure: true  # Dashboard on :8080 (internal only)

entryPoints:
  web:
    address: ":80"
  websecure:
    address: ":443"

providers:
  docker:
    endpoint: "unix:///var/run/docker.sock"
    exposedByDefault: false
    network: proxy
  file:
    directory: "/config"
    watch: true

log:
  level: INFO
  filePath: "/logs/traefik.log"

accessLog:
  filePath: "/logs/access.log"

certificatesResolvers:
  letsencrypt:
    acme:
      email: {acme_email}
      storage: /acme.json
      httpChallenge:
        entryPoint: web
"""
    return config


def generate_synology_routers_config(domain: str, nas_ip: str) -> str:
    """
    Generate Traefik router configuration for enabled Synology services.

    Args:
        domain: Base domain (e.g., konsume.org)
        nas_ip: IP address of the Synology NAS

    Returns:
        YAML snippet for routers section
    """
    enabled_services = get_enabled_synology_services()
    if not enabled_services:
        return ""

    lines = [
        "",
        "    # =========================================================================",
        "    # Synology NAS Services",
        "    # =========================================================================",
    ]

    for key, config in enabled_services.items():
        subdomain = config["subdomain"]
        lines.extend([
            f"",
            f"    # {config['description']} (HTTP -> HTTPS redirect)",
            f"    synology-{key}:",
            f"      rule: \"Host(`{subdomain}.{domain}`)\"",
            f"      service: synology-{key}",
            f"      entryPoints:",
            f"        - web",
            f"      middlewares:",
            f"        - https-redirect",
            f"",
            f"    # {config['description']} (HTTPS with Let's Encrypt)",
            f"    synology-{key}-secure:",
            f"      rule: \"Host(`{subdomain}.{domain}`)\"",
            f"      service: synology-{key}",
            f"      entryPoints:",
            f"        - websecure",
            f"      tls:",
            f"        certResolver: letsencrypt",
        ])

    return "\n".join(lines)


def generate_synology_services_config(nas_ip: str) -> str:
    """
    Generate Traefik service configuration for enabled Synology services.

    Args:
        nas_ip: IP address of the Synology NAS

    Returns:
        YAML snippet for services section
    """
    enabled_services = get_enabled_synology_services()
    if not enabled_services:
        return ""

    lines = [
        "",
        "  # ===========================================================================",
        "  # Synology NAS Services",
        "  # ===========================================================================",
        "  services:",
    ]

    for key, config in enabled_services.items():
        protocol = config["protocol"]
        port = config["port"]
        lines.extend([
            f"    synology-{key}:",
            f"      loadBalancer:",
            f"        servers:",
            f"          - url: \"{protocol}://{nas_ip}:{port}\"",
            f"        serversTransport: insecure-skip-verify@file",
        ])

    # Add serversTransport for self-signed certs on Synology
    lines.extend([
        "",
        "  serversTransports:",
        "    insecure-skip-verify:",
        "      insecureSkipVerify: true",
    ])

    return "\n".join(lines)


def generate_traefik_dynamic_config() -> str:
    """
    Generate Traefik dynamic configuration (config/dynamic.yml).

    Dynamic configuration can be updated without restarting Traefik.
    Defines routing rules, services, and middleware.

    Returns:
        YAML content as string
    """
    domain = os.getenv("DOMAIN", "example.com")
    nas_ip = os.getenv("NAS_IP", "")
    shim_ip = os.getenv("SHIM_IP", "")

    # For macvlan: Traefik container cannot reach NAS directly at NAS_IP.
    # It must use SHIM_IP (the macvlan shim interface) to reach the host.
    # If SHIM_IP is set, use it as the backend; otherwise fall back to NAS_IP.
    backend_ip = shim_ip if shim_ip else nas_ip

    # Generate Synology services config if backend IP is available
    synology_routers = ""
    synology_services = ""
    if backend_ip:
        synology_routers = generate_synology_routers_config(domain, backend_ip)
        synology_services = generate_synology_services_config(backend_ip)

    config = f"""# Traefik Dynamic Configuration
# Generated by SyrvisCore
# This file can be updated without restarting Traefik

http:
  routers:
    # =========================================================================
    # SyrvisCore Services
    # =========================================================================

    # Traefik Dashboard (HTTP -> HTTPS redirect)
    dashboard:
      rule: "Host(`traefik.{domain}`)"
      service: api@internal
      entryPoints:
        - web
      middlewares:
        - https-redirect

    # Traefik Dashboard (HTTPS with Let's Encrypt)
    dashboard-secure:
      rule: "Host(`traefik.{domain}`)"
      service: api@internal
      entryPoints:
        - websecure
      tls:
        certResolver: letsencrypt
{synology_routers}

  middlewares:
    # Redirect HTTP to HTTPS
    https-redirect:
      redirectScheme:
        scheme: https
        permanent: true
{synology_services}
"""
    return config


# =============================================================================
# Layer 2 Service Configuration
# =============================================================================


class ServiceTraefikConfig:
    """Generate Traefik dynamic configuration files for Layer 2 services.

    Each service gets its own config file in $SYRVIS_HOME/data/traefik/config/dynamic/
    that Traefik hot-reloads automatically via the file provider.

    The config files are placed in the Traefik config mount which maps to:
    - Host: $SYRVIS_HOME/data/traefik/config/
    - Container: /config/

    So files in $SYRVIS_HOME/data/traefik/config/dynamic/ appear as /config/dynamic/
    in the container, and Traefik watches the entire /config/ directory.
    """

    def __init__(self, config_dir: Optional[Path] = None):
        """Initialize the generator.

        Args:
            config_dir: Path to Traefik dynamic config directory.
                       Defaults to $SYRVIS_HOME/data/traefik/config/dynamic/
        """
        if config_dir:
            self.config_dir = config_dir
        else:
            syrvis_home = os.environ.get("SYRVIS_HOME", "")
            if not syrvis_home:
                raise ValueError("SYRVIS_HOME environment variable not set")
            # Use data/traefik/config/dynamic/ to match the volume mount
            self.config_dir = Path(syrvis_home) / "data" / "traefik" / "config" / "dynamic"

    def ensure_directory(self) -> None:
        """Ensure the dynamic config directory exists."""
        self.config_dir.mkdir(parents=True, exist_ok=True)

    def generate_config(
        self, service: "ServiceDefinition", domain: str
    ) -> Dict[str, Any]:
        """Generate Traefik configuration for a service.

        Args:
            service: Service definition
            domain: Base domain (e.g., "example.com")

        Returns:
            Traefik configuration dictionary
        """
        if not service.traefik.enabled or not service.traefik.subdomain:
            return {}

        host = f"{service.traefik.subdomain}.{domain}"
        name = service.name

        # Build router configurations
        config: Dict[str, Any] = {
            "http": {
                "routers": {
                    # HTTP router (redirects to HTTPS)
                    f"{name}-http": {
                        "entryPoints": ["web"],
                        "rule": f"Host(`{host}`)",
                        "middlewares": ["https-redirect"],
                        "service": name,
                    },
                    # HTTPS router
                    name: {
                        "entryPoints": ["websecure"],
                        "rule": f"Host(`{host}`)",
                        "tls": {
                            "certResolver": "letsencrypt",
                        },
                        "service": name,
                    },
                },
                "services": {
                    name: {
                        "loadBalancer": {
                            "servers": [
                                {
                                    "url": f"http://{service.container_name}:{service.traefik.port}"
                                }
                            ]
                        }
                    }
                },
            }
        }

        # Add custom middlewares if specified
        if service.traefik.middlewares:
            config["http"]["routers"][name]["middlewares"] = service.traefik.middlewares

        return config

    def write_config(self, service: "ServiceDefinition", domain: str) -> Optional[Path]:
        """Write Traefik configuration file for a service.

        Args:
            service: Service definition
            domain: Base domain

        Returns:
            Path to written config file, or None if no config needed
        """
        self.ensure_directory()

        config = self.generate_config(service, domain)
        if not config:
            # No Traefik config needed for this service
            return None

        config_path = self.config_dir / f"{service.name}.yaml"
        with open(config_path, "w") as f:
            yaml.dump(config, f, default_flow_style=False, sort_keys=False)

        return config_path

    def remove_config(self, service_name: str) -> bool:
        """Remove Traefik configuration file for a service.

        Args:
            service_name: Name of the service

        Returns:
            True if config was removed, False if it didn't exist
        """
        config_path = self.config_dir / f"{service_name}.yaml"
        if config_path.exists():
            config_path.unlink()
            return True
        return False

    def list_configs(self) -> List[str]:
        """List all service configs in the dynamic directory.

        Returns:
            List of service names with configs
        """
        if not self.config_dir.exists():
            return []

        return [f.stem for f in self.config_dir.glob("*.yaml")]


def get_domain_from_env() -> str:
    """Get the domain from environment variables.

    Returns:
        Domain string

    Raises:
        ValueError: If DOMAIN not set
    """
    domain = os.environ.get("DOMAIN", "")
    if not domain:
        # Try loading from .env file
        syrvis_home = os.environ.get("SYRVIS_HOME", "")
        if syrvis_home:
            env_file = Path(syrvis_home) / "config" / ".env"
            if env_file.exists():
                with open(env_file, "r") as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith("DOMAIN="):
                            domain = line.split("=", 1)[1].strip().strip('"').strip("'")
                            break

    if not domain:
        raise ValueError("DOMAIN environment variable not set")

    return domain
